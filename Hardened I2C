** IPExpress에서 EFB 에서 I2C 설정 후 사용.


	 // WISHBONE 신호 선언
    wire        wb_cyc;
    wire        wb_stb;
    wire        wb_we;
    wire [7:0]  wb_adr;
    wire [7:0]  wb_dat_i;
    wire [7:0]  wb_dat_o;
	reg [7:0]  wb_dat_o_reg;
    wire        wb_ack;
    wire        i2c_irq;

    // ✅ EFB I2C 모듈 인스턴스
    I2C I2C_inst (
        .wb_clk_i(clk),     // WISHBONE 클럭
        .wb_rst_i(!rst_n),  // WISHBONE 리셋 (Low Active)
        .wb_cyc_i(wb_cyc),  // 사이클 신호
        .wb_stb_i(wb_stb),  // 선택 신호
        .wb_we_i(wb_we),    // 쓰기 신호
        .wb_adr_i(wb_adr),  // WISHBONE 주소 입력
        .wb_dat_i(wb_dat_i),// 데이터 입력
        .wb_dat_o(wb_dat_o),// 데이터 출력
        .wb_ack_o(wb_ack),  // 응답 신호
        .i2c1_scl(i2c_scl), // I2C SCL
        .i2c1_sda(i2c_sda), // I2C SDA
        .i2c1_irqo(i2c_irq) // I2C 인터럽트
    );

    // ✅ WISHBONE 컨트롤 로직 (FPGA 내부에서 I2C 데이터를 처리)
    reg [7:0] reg_addr;  // I2C 명령 저장
    reg [7:0] reg_data;  // I2C 데이터 저장
    reg wb_ack_reg;

    assign wb_ack = wb_ack_reg;
    assign wb_dat_o = reg_data; // I2C Read 요청 시 FPGA가 반환할 데이터
	assign wb_dat_o = wb_dat_o_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wb_ack_reg <= 0;
            reg_addr   <= 8'h00;
            reg_data   <= 8'h00;
        end 
        else if (wb_cyc && wb_stb) begin
            wb_ack_reg <= 1;  // WISHBONE 응답 활성화
            
            if (wb_we) begin
				
                // ✅ I2C Write (마스터 → FPGA)
                if (reg_addr == 8'h00) begin
                    reg_addr <= wb_dat_i; // 첫 번째 Write는 "Register Address" 저장
                end else begin
                    reg_data <= wb_dat_i; // 두 번째 Write는 "Output Data" 저장
                end
				
				LED_Reg <= 8'hF0;
				
            end else begin
                // ✅ I2C Read (FPGA → 마스터)
                 wb_dat_o_reg <= reg_data; // 저장된 reg_data 값을 반환
				 
				 LED_Reg <= 8'h0F;
            end
        end 
        else begin
            wb_ack_reg <= 0;  // 트랜잭션 종료
        end
    end

	
