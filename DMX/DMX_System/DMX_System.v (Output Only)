// 4채널 기준으로 되어 있음.
// EBR이랑 FIFO 추가 해야 함. 둘다 8비트로
// 프로토콜은 UART 115200으로 받으며 $DIM,<PortNum>,<Channel>,<Dimming>*


탑에서 사용
// ---- 통합 DMX 시스템 ----
DMX_System #(.CLK_HZ(48_000_000)) u_sys (
  .clk(clk_48m), .rst_n(rst_n), .uart_rx(MCU_UART_RX),
  .DMX_TX_1(DMX_TX_1), .DMX_TX_2(DMX_TX_2), .DMX_TX_3(DMX_TX_3), .DMX_TX_4(DMX_TX_4),
  .DE_1(DE_1), .DE_2(DE_2), .DE_3(DE_3), .DE_4(DE_4)
);

// ============================================================================
// DMX_System.v  (ONE-FILE STACK, Lattice FIFO_DC 직접 연결 버전)
// UART Rx → FIFO_DC → Tokenizer('$'..'*', ',' sep) → Field Assembler → DIM Consumer
// → 4× DMX_Output_Module (Port-B write)
// ============================================================================

// ----------------------------------------------------------------------------
// UART Receiver (8-N-1), 16x oversampling, with 2FF sync
// ----------------------------------------------------------------------------
module UART_RX #(
    parameter integer CLK_HZ=48_000_000, BAUD=115_200, OVERSAMPLE=16, READY_WIDTH=4
)(
    input  wire clk, input wire rst_n,
    input  wire rx_i,               // idle=1
    output reg  [7:0] data,
    output reg        byte_ready,   // READY_WIDTH clocks
    output reg        byte_done,
    output reg        frame_err,
    output reg        rx_busy
);
    localparam integer DIV_ROUND=(CLK_HZ+(BAUD*OVERSAMPLE)/2)/(BAUD*OVERSAMPLE);
    localparam integer DIV=(DIV_ROUND<1)?1:DIV_ROUND;

    reg [$clog2(DIV)-1:0] div_cnt;  wire sample_tick=(div_cnt==0);
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) div_cnt <= 0; else div_cnt <= sample_tick? (DIV-1) : (div_cnt-1);
    end

    // 2FF input sync
    reg rx_sync1, rx_sync2;
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin rx_sync1<=1'b1; rx_sync2<=1'b1; end
        else begin rx_sync1<=rx_i; rx_sync2<=rx_sync1; end
    end
    wire rx = rx_sync2;

    // FSM
    localparam [1:0] S_IDLE=0,S_START=1,S_DATA=2,S_STOP=3;
    reg [1:0] st;
    reg [$clog2(OVERSAMPLE)-1:0] os_cnt;
    reg [2:0] bit_idx;
    reg [7:0] shreg;

    // ready stretch
    reg                       ready_load;
    reg [$clog2(READY_WIDTH+1)-1:0] ready_cnt;
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin ready_cnt<=0; byte_ready<=1'b0; end
        else begin
            if(ready_load) ready_cnt <= READY_WIDTH[$clog2(READY_WIDTH+1)-1:0];
            else if(ready_cnt!=0) ready_cnt <= ready_cnt - 1'b1;
            byte_ready <= (ready_cnt!=0);
        end
    end

    // simple gap detector
    localparam integer GAP_TICKS=20*OVERSAMPLE;
    reg [$clog2(GAP_TICKS+1)-1:0] gap_cnt;
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin gap_cnt<=0; byte_done<=1'b0; end
        else begin
            byte_done<=1'b0;
            if(!rx) gap_cnt<=0; else if(sample_tick && gap_cnt<GAP_TICKS) gap_cnt<=gap_cnt+1;
            if(gap_cnt==GAP_TICKS-1 && sample_tick) byte_done<=1'b1;
        end
    end

    // main
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            st<=S_IDLE; os_cnt<=0; bit_idx<=0; shreg<=8'h00; data<=8'h00; frame_err<=1'b0; rx_busy<=1'b0; ready_load<=1'b0;
        end else begin
            ready_load<=1'b0;
            if(sample_tick) begin
                case(st)
                    S_IDLE:  begin rx_busy<=1'b0; frame_err<=1'b0; if(!rx) begin os_cnt<=OVERSAMPLE/2; st<=S_START; rx_busy<=1'b1; end end
                    S_START: begin if(os_cnt==0) begin if(!rx) begin os_cnt<=OVERSAMPLE-1; bit_idx<=0; st<=S_DATA; end else st<=S_IDLE; end
                                     else os_cnt<=os_cnt-1; end
                    S_DATA:  begin if(os_cnt==0) begin shreg<={rx,shreg[7:1]}; os_cnt<=OVERSAMPLE-1; if(bit_idx==3'd7) st<=S_STOP; bit_idx<=bit_idx+1; end
                                     else os_cnt<=os_cnt-1; end
                    S_STOP:  begin if(os_cnt==0) begin frame_err<=(rx==1'b0); data<=shreg; ready_load<=1'b1; st<=S_IDLE; end
                                     else os_cnt<=os_cnt-1; end
                endcase
            end
        end
    end
endmodule

// ----------------------------------------------------------------------------
// UART_Rx_FIFO : UART_RX + FIFO_DC(IPexpress) 직접 인스턴스
//  - FIFO 모듈명: FIFO_UART_RX (IPX에서 생성된 이름 사용)
//  - 포트: Data(in), Q(out), WrClock, RdClock, WrEn, RdEn, Reset, RPReset, Empty, Full, AlmostEmpty, AlmostFull
// ----------------------------------------------------------------------------
module UART_Rx_FIFO #(
    parameter integer CLK_HZ=48_000_000, BAUD=115_200, OVERSAMPLE=16, READY_WIDTH=4
)(
    input  wire clk, input wire rst_n, input wire uart_rx,
    input  wire rd_en, output wire [7:0] dout, output wire empty, output wire full,
    output reg  [31:0] overrun_cnt
);
    wire [7:0] rx_data; wire rx_ready, rx_done, rx_ferr;
    UART_RX #(.CLK_HZ(CLK_HZ),.BAUD(BAUD),.OVERSAMPLE(OVERSAMPLE),.READY_WIDTH(READY_WIDTH)) u_rx (
      .clk(clk), .rst_n(rst_n), .rx_i(uart_rx),
      .data(rx_data), .byte_ready(rx_ready), .byte_done(rx_done), .frame_err(rx_ferr), .rx_busy()
    );

    wire [7:0] fifo_q; wire fifo_empty,fifo_full;
    wire fifo_aempty, fifo_afull;      // 더미 수신
    wire wr_en = rx_ready & ~fifo_full;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) overrun_cnt<=0;
        else if(rx_ready && fifo_full) overrun_cnt<=overrun_cnt+1'b1;
    end

    // >>> 여기서 네 IP 모듈명으로 변경 (아래는 예: FIFO_UART_RX)
    FIFO_UART_RX u_fifo (
      .Data        (rx_data),
      .Q           (fifo_q),
      .WrClock     (clk),
      .RdClock     (clk),
      .WrEn        (wr_en),
      .RdEn        (rd_en),
      .Reset       (~rst_n),
      .RPReset     (1'b0),
      .Empty       (fifo_empty),
      .Full        (fifo_full),
      .AlmostEmpty (fifo_aempty),
      .AlmostFull  (fifo_afull)
    );

    assign dout=fifo_q; assign empty=fifo_empty; assign full=fifo_full;
endmodule

// ----------------------------------------------------------------------------
// Tokenizer : '$'..'*' 프레임, ',' 구분자, CR/LF 무시
// ----------------------------------------------------------------------------
module UART_Rx_Processor (
    input wire clk, input wire rst_n,
    input wire UART_Empty, input wire [7:0] UART_Dout, output reg UART_RD_EN,
    output reg frame_start, output reg frame_end,
    output reg ch_valid, output reg [7:0] ch_data, output reg ch_is_sep
);
    localparam S_WAIT=0,S_POP=1,S_USE=2; reg [1:0] st; reg in_frame;
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            UART_RD_EN<=0; frame_start<=0; frame_end<=0; ch_valid<=0; ch_data<=8'h00; ch_is_sep<=0; st<=S_WAIT; in_frame<=0;
        end else begin
            UART_RD_EN<=0; frame_start<=0; frame_end<=0; ch_valid<=0; ch_is_sep<=0;
            case(st)
                S_WAIT: if(!UART_Empty) begin UART_RD_EN<=1; st<=S_POP; end
                S_POP : st<=S_USE;
                S_USE : begin
                    if(!in_frame) begin
                        if(UART_Dout==8'h24) begin in_frame<=1; frame_start<=1; end
                        if(!UART_Empty) begin UART_RD_EN<=1; st<=S_POP; end else st<=S_WAIT;
                    end else begin
                        if(UART_Dout==8'h2A) begin in_frame<=0; frame_end<=1; if(!UART_Empty) begin UART_RD_EN<=1; st<=S_POP; end else st<=S_WAIT; end
                        else if(UART_Dout==8'h0D || UART_Dout==8'h0A) begin if(!UART_Empty) begin UART_RD_EN<=1; st<=S_POP; end else st<=S_WAIT; end
                        else begin ch_data<=UART_Dout; ch_valid<=1; ch_is_sep <= (UART_Dout==8'h2C);
                             if(!UART_Empty) begin UART_RD_EN<=1; st<=S_POP; end else st<=S_WAIT; end
                    end
                end
            endcase
        end
    end
endmodule

// ----------------------------------------------------------------------------
// Field Assembler : 필드 버퍼링 + 숫자필드(int32) 파싱
// ----------------------------------------------------------------------------
module UART_FieldAssembler #(
    parameter integer MAX_FIELDS=8, MAX_FIELD_LEN=16
)(
    input wire clk, input wire rst_n,
    input wire frame_start, input wire frame_end,
    input wire ch_valid, input wire [7:0] ch_data, input wire ch_is_sep,
    output reg frame_done, output reg [7:0] field_count,
    input  wire [$clog2(MAX_FIELDS)-1:0]    rd_field,
    input  wire [$clog2(MAX_FIELD_LEN)-1:0] rd_index,
    output wire [7:0] rd_char, output wire rd_char_valid,
    output reg [MAX_FIELDS*8-1:0]  field_len_bus,
    output reg [MAX_FIELDS-1:0]    is_digit_only_mask,
    output reg [MAX_FIELDS*32-1:0] int_values_bus,
    output reg [31:0] overrun_count
);
    localparam integer MEM_SIZE=MAX_FIELDS*MAX_FIELD_LEN;
    (* ram_style="distributed" *) reg [7:0] mem [0:MEM_SIZE-1];
    reg [7:0]  field_len[0:MAX_FIELDS-1];
    reg        is_digit_only[0:MAX_FIELDS-1];
    reg [31:0] int_value[0:MAX_FIELDS-1];
    reg        int_neg[0:MAX_FIELDS-1];
    reg [$clog2(MAX_FIELDS)-1:0]    cur_field;
    reg [$clog2(MAX_FIELD_LEN)-1:0] cur_index;

    wire [$clog2(MEM_SIZE)-1:0] wr_addr = cur_field*MAX_FIELD_LEN+cur_index;
    wire [$clog2(MEM_SIZE)-1:0] rd_addr = rd_field*MAX_FIELD_LEN+rd_index;

    assign rd_char=mem[rd_addr];
    assign rd_char_valid=(rd_index<field_len[rd_field]);

    integer i;
    task pack; integer k; begin
        for(k=0;k<MAX_FIELDS;k=k+1) begin
            field_len_bus[8*k +: 8] = field_len[k];
            is_digit_only_mask[k]   = is_digit_only[k];
            int_values_bus[32*k +:32]= int_neg[k]? (~int_value[k]+1):int_value[k];
        end
    end endtask

    wire is_digit=(ch_data>=8'h30 && ch_data<=8'h39);
    wire is_sign =(ch_data==8'h2B || ch_data==8'h2D);

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            frame_done<=0; field_count<=0; cur_field<=0; cur_index<=0; overrun_count<=0;
            for(i=0;i<MAX_FIELDS;i=i+1) begin field_len[i]<=0; is_digit_only[i]<=1; int_value[i]<=0; int_neg[i]<=0; end
            pack();
        end else begin
            frame_done<=0;
            if(frame_start) begin
                cur_field<=0; cur_index<=0; field_count<=0;
                for(i=0;i<MAX_FIELDS;i=i+1) begin field_len[i]<=0; is_digit_only[i]<=1; int_value[i]<=0; int_neg[i]<=0; end
                pack();
            end
            if(ch_valid) begin
                if(ch_is_sep) begin
                    if(cur_field<MAX_FIELDS-1) begin cur_field<=cur_field+1; cur_index<=0; field_count <= (field_count<MAX_FIELDS)?(field_count+1):field_count; end
                end else begin
                    if(cur_field<MAX_FIELDS) begin
                        if(cur_index<MAX_FIELD_LEN) begin
                            mem[wr_addr]<=ch_data; cur_index<=cur_index+1; field_len[cur_field]<=field_len[cur_field]+1;
                            if(is_digit_only[cur_field]) begin
                                if(field_len[cur_field]==0) begin
                                    if(is_sign) int_neg[cur_field] <= (ch_data==8'h2D);
                                    else if(is_digit) int_value[cur_field] <= (ch_data-8'h30);
                                    else is_digit_only[cur_field] <= 1'b0;
                                end else begin
                                    if(is_digit) int_value[cur_field] <= (int_value[cur_field]*10) + (ch_data-8'h30);
                                    else is_digit_only[cur_field] <= 1'b0;
                                end
                            end
                        end else overrun_count<=overrun_count+1;
                    end
                end
            end
            if(frame_end) begin
                if(cur_field<MAX_FIELDS) field_count<=cur_field+1;
                frame_done<=1; pack();
            end
        end
    end
endmodule

// ----------------------------------------------------------------------------
// UART_Rx_Stack (bundle)
// ----------------------------------------------------------------------------
module UART_Rx_Stack #(
    parameter integer CLK_HZ=48_000_000, BAUD=115_200, MAX_FIELDS=8, MAX_FIELD_LEN=16
)(
    input wire clk, input wire rst_n, input wire uart_rx,
    output wire frame_done, output wire [7:0] field_count,
    output wire [MAX_FIELDS*8-1:0]  field_len_bus,
    output wire [MAX_FIELDS-1:0]    is_digit_only_mask,
    output wire [MAX_FIELDS*32-1:0] int_values_bus,
    input  wire [$clog2(MAX_FIELDS)-1:0]    rd_field,
    input  wire [$clog2(MAX_FIELD_LEN)-1:0] rd_index,
    output wire [7:0] rd_char, output wire rd_char_valid,
    output wire [31:0] uart_overrun_cnt
);
    wire [7:0] fifo_dout; wire fifo_empty,fifo_full; wire rd_en_pulse;
    UART_Rx_FIFO #(.CLK_HZ(CLK_HZ),.BAUD(BAUD)) u_rxfifo(
      .clk(clk), .rst_n(rst_n), .uart_rx(uart_rx),
      .rd_en(rd_en_pulse), .dout(fifo_dout), .empty(fifo_empty), .full(fifo_full),
      .overrun_cnt(uart_overrun_cnt)
    );

    wire frame_start,frame_end_w, ch_valid, ch_is_sep; wire [7:0] ch_data;
    UART_Rx_Processor u_tok(
      .clk(clk), .rst_n(rst_n),
      .UART_Empty(fifo_empty), .UART_Dout(fifo_dout), .UART_RD_EN(rd_en_pulse),
      .frame_start(frame_start), .frame_end(frame_end_w),
      .ch_valid(ch_valid), .ch_data(ch_data), .ch_is_sep(ch_is_sep)
    );

    UART_FieldAssembler #(.MAX_FIELDS(MAX_FIELDS),.MAX_FIELD_LEN(MAX_FIELD_LEN)) u_fasm(
      .clk(clk), .rst_n(rst_n),
      .frame_start(frame_start), .frame_end(frame_end_w),
      .ch_valid(ch_valid), .ch_data(ch_data), .ch_is_sep(ch_is_sep),
      .frame_done(frame_done), .field_count(field_count),
      .rd_field(rd_field), .rd_index(rd_index),
      .rd_char(rd_char), .rd_char_valid(rd_char_valid),
      .field_len_bus(field_len_bus), .is_digit_only_mask(is_digit_only_mask),
      .int_values_bus(int_values_bus), .overrun_count()
    );
endmodule

// ----------------------------------------------------------------------------
// UART_DIM_Consumer : $DIM,<port>,<channel>,<level>*
// ----------------------------------------------------------------------------
module UART_DIM_Consumer #(
    parameter integer MAX_FIELDS=8, MAX_FIELD_LEN=16
)(
    input wire clk, input wire rst_n,
    input wire frame_done, input wire [7:0] field_count,
    input wire [MAX_FIELDS*8-1:0]   field_len_bus,
    input wire [MAX_FIELDS-1:0]     is_digit_only_mask,
    input wire [MAX_FIELDS*32-1:0]  int_values_bus,
    output reg  [$clog2(MAX_FIELDS)-1:0]    rd_field,
    output reg  [$clog2(MAX_FIELD_LEN)-1:0] rd_index,
    input  wire [7:0] rd_char, input wire rd_char_valid,
    output reg        cmd_dim_valid,
    output reg  [1:0] dim_port, output reg [9:0] dim_channel, output reg [7:0] dim_level,
    output reg        err_fieldcount, err_nonnumeric, err_range, unknown_cmd, parse_busy
);
    wire [7:0]  len0  = field_len_bus[7:0];
    wire        isnum1= is_digit_only_mask[1];
    wire        isnum2= is_digit_only_mask[2];
    wire        isnum3= is_digit_only_mask[3];
    wire [31:0] int1  = int_values_bus[63:32];
    wire [31:0] int2  = int_values_bus[95:64];
    wire [31:0] int3  = int_values_bus[127:96];

    reg [2:0] st; localparam S_IDLE=0,S_CMD0_INIT=1,S_CMD0_RD=2,S_CMD0_CMP=3,S_LATCH=4,S_VALID=5,S_DONE=6;
    localparam [7:0] C_D=8'h44,C_I=8'h49,C_M=8'h4D; reg [1:0] idx; reg [7:0] exp; reg match;
    reg [31:0] tmp_p,tmp_c,tmp_l;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            st<=S_IDLE; rd_field<=0; rd_index<=0; idx<=0; exp<=0; match<=0;
            cmd_dim_valid<=0; err_fieldcount<=0; err_nonnumeric<=0; err_range<=0; unknown_cmd<=0; parse_busy<=0;
            dim_port<=0; dim_channel<=0; dim_level<=0; tmp_p<=0; tmp_c<=0; tmp_l<=0;
        end else begin
            cmd_dim_valid<=0; err_fieldcount<=0; err_nonnumeric<=0; err_range<=0; unknown_cmd<=0;
            case(st)
              S_IDLE: begin
                parse_busy<=0;
                if(frame_done) begin parse_busy<=1; rd_field<=0; rd_index<=0; idx<=0; match<=0; st<=S_CMD0_INIT; end
              end
              S_CMD0_INIT: begin
                if(len0!=8'd3) begin match<=0; st<=S_LATCH; end else st<=S_CMD0_RD;
              end
              S_CMD0_RD:   st<=S_CMD0_CMP;
              S_CMD0_CMP: begin
                case(idx) 2'd0:exp<=C_D; 2'd1:exp<=C_I; default:exp<=C_M; endcase
                if(!rd_char_valid || rd_char!=exp) begin match<=0; st<=S_LATCH; end
                else if(idx==2'd2) begin match<=1; st<=S_LATCH; end
                else begin idx<=idx+1; rd_index<=rd_index+1; st<=S_CMD0_RD; end
              end
              S_LATCH: begin
                if(field_count<8'd4) begin err_fieldcount<=1; st<=S_DONE; end
                else begin tmp_p<=int1; tmp_c<=int2; tmp_l<=int3; st<=S_VALID; end
              end
              S_VALID: begin
                if(!match) begin unknown_cmd<=1; st<=S_DONE; end
                else if(!(isnum1&&isnum2&&isnum3)) begin err_nonnumeric<=1; st<=S_DONE; end
                else if(!((tmp_p<=3)&&(tmp_c>=1&&tmp_c<=512)&&(tmp_l<=255))) begin err_range<=1; st<=S_DONE; end
                else begin dim_port<=tmp_p[1:0]; dim_channel<=tmp_c[9:0]; dim_level<=tmp_l[7:0]; cmd_dim_valid<=1; st<=S_DONE; end
              end
              S_DONE: begin parse_busy<=0; st<=S_IDLE; end
            endcase
        end
    end
endmodule

// ----------------------------------------------------------------------------
// DMX_Output_Module  (네 코드 포함, 모듈명 EBR 가정)
// ----------------------------------------------------------------------------
module DMX_Output_Module #(
    parameter CLK_FREQ = 48_000_000,
    parameter BAUD_RATE = 250_000,
    parameter WAIT_CYCLES = 10
)(
    input wire clk, input wire rst_n,
    input  wire [9:0] EBR_Addr_B,
    input  wire [7:0] EBR_DataIn_B,
    input  wire       EBR_WrB,
    input  wire [9:0] Channel_Count,
    input  wire       Enable,
    input  wire [1:0] FREQ_MODE,  // 00:10Hz ~ 11:40Hz
    output reg        DE,
    output reg        DMX_Output_Signal
);
    localparam BIT_TIME   = CLK_FREQ / BAUD_RATE;
    localparam BREAK_TIME = (CLK_FREQ / 1_000_000) * 100;  // 100us
    localparam MAB_TIME   = (CLK_FREQ / 1_000_000) * 20;   // 20us

    reg [31:0] packet_timer;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) packet_timer <= CLK_FREQ / 40;
        else case (FREQ_MODE)
            2'b00: packet_timer <= CLK_FREQ / 10;
            2'b01: packet_timer <= CLK_FREQ / 20;
            2'b10: packet_timer <= CLK_FREQ / 30;
            2'b11: packet_timer <= CLK_FREQ / 40;
            default: packet_timer <= CLK_FREQ / 40;
        endcase
    end

    reg [31:0] packet_counter;
    reg start_tx;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin packet_counter<=0; start_tx<=0; end
        else if (Enable) begin
            if (packet_counter >= packet_timer) begin packet_counter<=0; start_tx<=1; end
            else begin packet_counter<=packet_counter+1; start_tx<=0; end
        end else begin packet_counter<=0; start_tx<=0; end
    end

    // EBR (Port A Read / Port B Write)
    reg  [9:0] EBR_Addr_A;
    wire [7:0] EBR_QA;

    EBR EBR_Inst (
        .ClockA(clk), .ClockB(clk),
        .ClockEnA(1'b1), .ClockEnB(1'b1),
        .ResetA(~rst_n), .ResetB(~rst_n),
        .AddressA(EBR_Addr_A), .WrA(1'b0), .QA(EBR_QA),
        .AddressB(EBR_Addr_B), .DataInB(EBR_DataIn_B), .WrB(EBR_WrB)
    );

    localparam IDLE=0, BREAK=1, MAB=2, WAIT_READ=3, START_BIT=4, DATA_BITS=5, LAST_BIT_HOLD=6, STOP_BITS=7;
    reg [3:0] state; reg [4:0] wait_counter; reg [15:0] counter; reg [3:0] bit_index; reg [9:0] byte_index; reg [7:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state<=IDLE; counter<=0; bit_index<=0; byte_index<=0; DE<=1; DMX_Output_Signal<=1; EBR_Addr_A<=0;
        end else begin
            case (state)
                IDLE: begin
                    if (start_tx) begin byte_index<=0; EBR_Addr_A<=0; counter<=0; DMX_Output_Signal<=0; state<=BREAK; end
                end
                BREAK: begin
                    if (counter < BREAK_TIME) counter<=counter+1;
                    else begin counter<=0; DMX_Output_Signal<=1; state<=MAB; end
                end
                MAB: begin
                    if (counter < MAB_TIME) counter<=counter+1;
                    else begin wait_counter<=0; state<=WAIT_READ; end
                end
                WAIT_READ: begin
                    if (wait_counter==0) EBR_Addr_A<=byte_index;
                    if (wait_counter < WAIT_CYCLES-1) wait_counter<=wait_counter+1;
                    else begin counter<=0; bit_index<=0; DMX_Output_Signal<=0; shift_reg<=EBR_QA; state<=START_BIT; end
                end
                START_BIT: begin
                    if (counter < BIT_TIME) begin counter<=counter+1; DMX_Output_Signal<=0; end
                    else begin counter<=0; DMX_Output_Signal<=shift_reg[0]; shift_reg<=shift_reg>>1; bit_index<=1; state<=DATA_BITS; end
                end
                DATA_BITS: begin
                    if (counter < BIT_TIME) counter<=counter+1;
                    else begin
                        counter<=0; DMX_Output_Signal<=shift_reg[0]; shift_reg<=shift_reg>>1; bit_index<=bit_index+1;
                        if (bit_index==7) state<=LAST_BIT_HOLD;
                    end
                end
                LAST_BIT_HOLD: begin
                    if (counter < BIT_TIME) counter<=counter+1;
                    else begin counter<=0; EBR_Addr_A<=byte_index+1; byte_index<=byte_index+1; state<=STOP_BITS; end
                end
                STOP_BITS: begin
                    if (counter < 2*BIT_TIME) begin DMX_Output_Signal<=1; counter<=counter+1; end
                    else begin
                        counter<=0;
                        if (byte_index < Channel_Count) begin state<=WAIT_READ; wait_counter<=0; end
                        else state<=IDLE;
                    end
                end
            endcase
        end
    end
endmodule

// ----------------------------------------------------------------------------
// DMX_System (Top-level for integration)
// ----------------------------------------------------------------------------
module DMX_System #(
    parameter integer CLK_HZ=48_000_000
)(
    input  wire clk, input wire rst_n, input wire uart_rx,
    output wire DMX_TX_1, output wire DMX_TX_2, output wire DMX_TX_3, output wire DMX_TX_4,
    output wire DE_1, output wire DE_2, output wire DE_3, output wire DE_4
);
    // 1) UART 수신 + 파서
    wire        frame_done; wire [7:0] field_count;
    wire [8*8-1:0]  field_len_bus; wire [7:0] is_digit_only_mask; wire [32*8-1:0] int_values_bus;
    wire [$clog2(8)-1:0]  rd_field; wire [$clog2(16)-1:0] rd_index; wire [7:0] rd_char; wire rd_char_valid;
    wire [31:0] uart_overrun_cnt;

    UART_Rx_Stack #(.CLK_HZ(CLK_HZ),.BAUD(115_200),.MAX_FIELDS(8),.MAX_FIELD_LEN(16)) u_stack(
      .clk(clk), .rst_n(rst_n), .uart_rx(uart_rx),
      .frame_done(frame_done), .field_count(field_count),
      .field_len_bus(field_len_bus), .is_digit_only_mask(is_digit_only_mask), .int_values_bus(int_values_bus),
      .rd_field(rd_field), .rd_index(rd_index), .rd_char(rd_char), .rd_char_valid(rd_char_valid),
      .uart_overrun_cnt(uart_overrun_cnt)
    );

    // 2) DIM Consumer
    wire        cmd_dim_valid; wire [1:0] dim_port; wire [9:0] dim_channel; wire [7:0] dim_level;
    wire        err_fieldcount, err_nonnumeric, err_range, unknown_cmd, parse_busy;

    UART_DIM_Consumer #(.MAX_FIELDS(8),.MAX_FIELD_LEN(16)) u_dim(
      .clk(clk), .rst_n(rst_n),
      .frame_done(frame_done), .field_count(field_count),
      .field_len_bus(field_len_bus), .is_digit_only_mask(is_digit_only_mask), .int_values_bus(int_values_bus),
      .rd_field(rd_field), .rd_index(rd_index), .rd_char(rd_char), .rd_char_valid(rd_char_valid),
      .cmd_dim_valid(cmd_dim_valid), .dim_port(dim_port), .dim_channel(dim_channel), .dim_level(dim_level),
      .err_fieldcount(err_fieldcount), .err_nonnumeric(err_nonnumeric), .err_range(err_range),
      .unknown_cmd(unknown_cmd), .parse_busy(parse_busy)
    );

    // 3) 포트별 EBR Port-B write
    reg wr0_p,wr1_p,wr2_p,wr3_p; reg [9:0] a0,a1,a2,a3; reg [7:0] d0,d1,d2,d3;
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin wr0_p<=0;wr1_p<=0;wr2_p<=0;wr3_p<=0; a0<=0;a1<=0;a2<=0;a3<=0; d0<=0;d1<=0;d2<=0;d3<=0; end
        else begin
            wr0_p<=0; wr1_p<=0; wr2_p<=0; wr3_p<=0;
            if(cmd_dim_valid) begin
                case(dim_port)
                  2'd0: begin a0<=dim_channel-1; d0<=dim_level; wr0_p<=1; end
                  2'd1: begin a1<=dim_channel-1; d1<=dim_level; wr1_p<=1; end
                  2'd2: begin a2<=dim_channel-1; d2<=dim_level; wr2_p<=1; end
                  default: begin a3<=dim_channel-1; d3<=dim_level; wr3_p<=1; end
                endcase
            end
        end
    end

    // 4) DMX 송출 모듈 4개
    DMX_Output_Module #(.CLK_FREQ(CLK_HZ),.BAUD_RATE(250_000),.WAIT_CYCLES(10)) DMX1(
      .clk(clk), .rst_n(rst_n),
      .EBR_Addr_B(a0), .EBR_DataIn_B(d0), .EBR_WrB(wr0_p),
      .Channel_Count(10'd512), .Enable(1'b1), .FREQ_MODE(2'b10),
      .DE(DE_1), .DMX_Output_Signal(DMX_TX_1)
    );
    DMX_Output_Module #(.CLK_FREQ(CLK_HZ),.BAUD_RATE(250_000),.WAIT_CYCLES(10)) DMX2(
      .clk(clk), .rst_n(rst_n),
      .EBR_Addr_B(a1), .EBR_DataIn_B(d1), .EBR_WrB(wr1_p),
      .Channel_Count(10'd512), .Enable(1'b1), .FREQ_MODE(2'b10),
      .DE(DE_2), .DMX_Output_Signal(DMX_TX_2)
    );
    DMX_Output_Module #(.CLK_FREQ(CLK_HZ),.BAUD_RATE(250_000),.WAIT_CYCLES(10)) DMX3(
      .clk(clk), .rst_n(rst_n),
      .EBR_Addr_B(a2), .EBR_DataIn_B(d2), .EBR_WrB(wr2_p),
      .Channel_Count(10'd512), .Enable(1'b1), .FREQ_MODE(2'b10),
      .DE(DE_3), .DMX_Output_Signal(DMX_TX_3)
    );
    DMX_Output_Module #(.CLK_FREQ(CLK_HZ),.BAUD_RATE(250_000),.WAIT_CYCLES(10)) DMX4(
      .clk(clk), .rst_n(rst_n),
      .EBR_Addr_B(a3), .EBR_DataIn_B(d3), .EBR_WrB(wr3_p),
      .Channel_Count(10'd512), .Enable(1'b1), .FREQ_MODE(2'b10),
      .DE(DE_4), .DMX_Output_Signal(DMX_TX_4)
    );
endmodule
